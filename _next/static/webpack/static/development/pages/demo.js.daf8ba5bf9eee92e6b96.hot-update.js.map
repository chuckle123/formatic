{"version":3,"file":"static/webpack/static/development/pages/demo.js.daf8ba5bf9eee92e6b96.hot-update.js","sources":["webpack:///./demo/examples/pretty-text.js","webpack:///./pages/demo.js","webpack:///./src/components/helpers/pretty-text-input.js"],"sourcesContent":["const fields = [\n  {\n    label: 'Pretty Text',\n    key: 'prettyText',\n    type: 'pretty-text',\n    default: 'Hi there {{firstName}} {{lastName}} {{middleName}}.',\n    choices: [\n      {\n        value: 'lastName',\n        label: 'Last Name',\n        sample: 'Smith',\n      },\n      {\n        value: 'middleName',\n        label:\n          'A really long label that should break somewhere in the middle and then definitely fill up all the space.',\n      },\n    ],\n    replaceChoices: [\n      {\n        value: 'firstName',\n        label: 'First Name',\n        sample: 'Bob',\n        tagClasses: {\n          special: true,\n        },\n      },\n      {\n        value: 'lastName',\n        label: 'Last Name',\n        sample: 'Smith',\n      },\n      {\n        value: 'middleName',\n        label:\n          'A really long label that should break somewhere in the middle and then definitely fill up all the space.',\n      },\n    ],\n  },\n  {\n    label: 'Pretty Text with integer default',\n    key: 'integerPrettyText',\n    type: 'pretty-text',\n    default: 1,\n    placeholder: 1,\n  },\n  {\n    label: 'Group',\n    type: 'fields',\n    fields: [\n      {\n        label: 'Pretty Text with integer default',\n        key: 'integerPrettyTextGrouped',\n        type: 'pretty-text',\n        default: 1,\n        placeholder: 1,\n      },\n    ],\n  },\n  {\n    label: 'Readonly pretty text',\n    key: 'readonlyPrettyText',\n    type: 'pretty-text',\n    default: \"Nah nah you can't edit me\",\n    readOnly: true,\n  },\n  {\n    label: 'Accordion Names',\n    key: 'nestedPrettyText',\n    type: 'pretty-text',\n    isAccordion: true,\n    default: 'Hi there {{firstName}} {{lastName}} {{middleName}}.',\n    isLoading: true,\n    replaceChoices: [\n      {\n        label: 'Name',\n        value: 'name',\n      },\n      {\n        label: 'Hi Class People',\n        sectionKey: 'hiClass',\n      },\n      {\n        value: 'givenName',\n        label: 'Given Name',\n        sample: 'Sir Duke',\n        tagClasses: {\n          special: true,\n        },\n      },\n      {\n        value: 'surname',\n        label: 'Surname',\n        sample: 'Ellington',\n      },\n      {\n        label: 'Lo Class People',\n        sectionKey: 'loClass',\n      },\n      {\n        value: 'firstName',\n        label: 'First Name',\n        sample: 'Peasant',\n      },\n      {\n        value: 'lastName',\n        label: 'Last Name',\n        sample: 'Brown',\n      },\n      {\n        sectionKey: null,\n        value: 'extraName',\n        label: 'Extra Name',\n        sample: 'Extra',\n      },\n    ],\n  },\n];\n\nexport default {\n  title: 'Pretty Text',\n  aliases: ['pretty-text', 'pretty-textarea'],\n  notes: null,\n  fields,\n};\n","import React, { Component } from 'react';\nimport _ from 'lodash';\nimport Formatic from '@/src/formatic';\n\nimport Page from '@/docs/components/Page';\nimport Sections from '@/docs/components/Sections';\nimport Section from '@/docs/components/Section';\nimport Button from '@/docs/components/Button';\n\nimport examples from '@/demo/examples';\n\nimport customPlugin from '@/demo/examples/custom-plugin';\nimport cssPlugin from '@/src/plugins/css-plugin';\n\nconst Form = React.createFactory(Formatic);\n\n// Draws a hint box around each component.\nconst HintBox = props => (\n  <div\n    style={{\n      padding: '1px',\n      margin: '1px',\n      border: '1px solid black',\n      display: 'inline-block',\n    }}\n  >\n    <span style={{ fontStyle: 'italic', fontSize: '12px' }}>{props.name}</span>\n    {props.children}\n  </div>\n);\n\n// Inject a HintBox into each createElement_ hook to show hints\n// for plugin methods.\nconst hintPlugin = config => {\n  const prevConfig = _.extend({}, config);\n  return Object.keys(config).reduce(\n    (newConfig, key) => {\n      if (key.startsWith('createElement_')) {\n        newConfig[key] = props => (\n          <HintBox key={props.key} name={key}>\n            {prevConfig[key](props)}\n          </HintBox>\n        );\n      }\n      return newConfig;\n    },\n    {\n      renderTag: (tag, tagProps, metaProps, ...children) => {\n        return (\n          <HintBox\n            name={`renderTag:(${tag}:${metaProps.typeName}:${\n              metaProps.elementName\n            })`}\n          >\n            {prevConfig.renderTag(tag, tagProps, metaProps, ...children)}\n          </HintBox>\n        );\n      },\n    }\n  );\n};\n\nconst config = Formatic.createConfig(\n  cssPlugin,\n  Formatic.plugins.reference,\n  Formatic.plugins.meta,\n  customPlugin\n);\n\nconst hintConfig = Formatic.createConfig(\n  cssPlugin,\n  Formatic.plugins.reference,\n  Formatic.plugins.meta,\n  customPlugin,\n  hintPlugin\n);\n\nconst convertTitleToId = title => title.toLowerCase().replace(/ /g, '-');\n\nconst DisplayFormValue = props => (\n  <div>\n    <h5>{props.title} Form State:</h5>\n    <pre>{JSON.stringify(props.value, null, 2)}</pre>\n  </div>\n);\n\nconst generateAliases = aliases =>\n  aliases\n    .map((alias, idx) => (\n      <span className=\"code\" key={idx}>\n        {alias}\n      </span>\n    ))\n    .reduce(\n      (acc, elem) => (acc === null ? [elem] : [...acc, ', ', elem]),\n      null\n    );\n\nclass FormDemo extends Component {\n  constructor(props) {\n    super();\n\n    this.state = {\n      formState: config.createRootValue(props),\n      fields: props.fields,\n      hints: {},\n    };\n  }\n\n  onChange(newValue, info) {\n    console.info('onChange:', newValue);\n    console.info('Field Info:', info);\n\n    this.setState({\n      formState: newValue,\n    });\n  }\n\n  onChangeFields(newValue) {\n    this.setState({\n      fields: newValue.source,\n    });\n  }\n\n  onChangeHint(id) {\n    const hints = _.extend({}, this.state.hints);\n    hints[id] = !hints[id];\n    this.setState({\n      hints,\n    });\n  }\n\n  onEvent(eventName, event) {\n    console.info(eventName, event.path, event.field);\n  }\n\n  onCustomEvent(eventName, info) {\n    console.info(eventName, info);\n  }\n\n  render() {\n    const { title, notes, aliases } = this.props;\n\n    const aliasContent = !aliases ? null : (\n      <p>Aliases: {generateAliases(aliases)}</p>\n    );\n\n    const typeName = convertTitleToId(title);\n\n    const typeContent =\n      typeName === 'unknown-field' ? null : (\n        <p>\n          Type: <span className=\"code\">{convertTitleToId(title)}</span>\n        </p>\n      );\n\n    const id = convertTitleToId(title);\n\n    return (\n      <div id={id}>\n        <div className=\"row\">\n          <div className=\"col-sm-12\">\n            {/* <h3>\n              {title}\n              <a className=\"form-link\" href={`#${convertTitleToId(title)}`}>\n                <span className=\"glyphicon glyphicon-link\" />\n              </a>\n            </h3> */}\n            <hr />\n            {typeContent}\n            {aliasContent}\n            <p>\n              <Button onClick={() => this.onChangeHint(id)}>\n                Toggle Plugin Hints\n              </Button>\n            </p>\n            <p>{notes}</p>\n          </div>\n        </div>\n        <div className=\"row\">\n          <div className=\"col-sm-8\">\n            <div className=\"form-example\">\n              <Form\n                config={this.state.hints[id] ? hintConfig : config}\n                fields={this.state.fields}\n                onBlur={e => this.onEvent('onBlur', e)}\n                onChange={this.onChange.bind(this)}\n                onClearCurrentChoice={info =>\n                  this.onCustomEvent('onClearCurrentChoice', info)\n                }\n                onCloseReplacements={info =>\n                  this.onCustomEvent('onCloseReplacements', info)\n                }\n                onFocus={e => this.onEvent('onFocus', e)}\n                onOpenReplacements={info =>\n                  this.onCustomEvent('onOpenReplacements', info)\n                }\n                onOrderGroceries={info =>\n                  this.onCustomEvent('onOrderGroceries', info)\n                }\n                readOnly={false}\n                value={this.state.formState}\n              />\n            </div>\n          </div>\n          <div className=\"col-sm-4\">\n            <DisplayFormValue title={title} value={this.state.formState} />\n          </div>\n        </div>\n        <div className=\"row\">\n          <div className=\"col-sm-12\">\n            <Form\n              config={config}\n              fields={{\n                type: 'fieldset',\n                collapsed: true,\n                label: 'Example JSON',\n                fields: [\n                  {\n                    key: 'source',\n                    type: 'json',\n                    default: this.state.fields,\n                  },\n                ],\n              }}\n              onChange={this.onChangeFields.bind(this)}\n            />\n          </div>\n        </div>\n      </div>\n    );\n  }\n}\n\nconst sortedExamples = _.sortBy(examples, ['title']);\n\nconst DemoPage = () => (\n  <Page pageKey=\"demo\">\n    <Sections>\n      {sortedExamples.map((form, idx) => (\n        <Section key={form.title} title={form.title}>\n          <FormDemo key={idx} {...form} />\n        </Section>\n      ))}\n    </Sections>\n  </Page>\n);\n\nexport default DemoPage;\n","'use strict';\n\n/*eslint no-script-url:0 */\n\nimport createReactClass from 'create-react-class';\nimport ReactDOM from 'react-dom';\nimport cx from 'classnames';\n\nimport TagTranslator from './tag-translator';\nimport _ from '@/src/undash';\nimport { keyCodes, ref } from '@/src/utils';\nimport HelperMixin from '@/src/mixins/helper';\n\n/** @jsx jsx */\nimport jsx from '@/src/jsx';\n\nconst toString = function(value) {\n  if (_.isUndefined(value) || _.isNull(value)) {\n    return '';\n  }\n  return String(value);\n};\n\n/*\n   Editor for tagged text. Renders text like \"hello {{firstName}}\"\n   with replacement labels rendered in a pill box. Designed to load\n   quickly when many separate instances of it are on the same\n   page.\n\n   Uses CodeMirror to edit text. To save memory the CodeMirror node is\n   instantiated when the user moves the mouse into the edit area.\n   Initially a read-only view using a simple div is shown.\n */\nexport default createReactClass({\n  displayName: 'PrettyTextInput',\n\n  mixins: [HelperMixin],\n\n  componentDidMount: function() {\n    this.createEditor();\n  },\n\n  componentDidUpdate: function(prevProps, prevState) {\n    const hasReplaceChoicesChanged = !_.isEqual(\n      prevProps.replaceChoices,\n      this.props.replaceChoices\n    );\n    const hasCodeMirrorModeChanged =\n      prevState.codeMirrorMode !== this.state.codeMirrorMode;\n    if (hasCodeMirrorModeChanged || hasReplaceChoicesChanged) {\n      // Changed from code mirror mode to read only mode or vice versa,\n      // so setup the other editor.\n      this.createEditor();\n    }\n    this.updateEditor();\n  },\n\n  componentWillUnmount: function() {\n    if (this.state.codeMirrorMode) {\n      this.removeCodeMirrorEditor();\n    }\n  },\n\n  getInitialState: function() {\n    const selectedChoices = this.props.selectedChoices;\n    const replaceChoices = this.props.replaceChoices;\n    const translator = TagTranslator(\n      selectedChoices.concat(replaceChoices),\n      this.props.config.humanize\n    );\n\n    return {\n      // With number values, onFocus never fires, which means it stays read-only. So convert to string.\n      value: toString(this.props.value),\n      codeMirrorMode: false,\n      isChoicesOpen: false,\n      replaceChoices,\n      translator,\n      hasChanged: false,\n    };\n  },\n\n  componentWillReceiveProps: function(nextProps) {\n    // If we're debouncing a change, then we should just ignore this props change,\n    // because there will be another when we hit the trailing edge of the debounce.\n    if (this.debouncedOnChangeAndTagCodeMirror) {\n      return;\n    }\n\n    const selectedChoices = nextProps.selectedChoices;\n    const replaceChoices = nextProps.replaceChoices;\n    const nextState = {\n      replaceChoices,\n      translator: TagTranslator(\n        selectedChoices.concat(replaceChoices),\n        this.props.config.humanize\n      ),\n    };\n\n    // Not sure what the null/undefined checks are here for, but changed from falsey which was breaking.\n    if (\n      this.state.value !== nextProps.value &&\n      !_.isUndefined(nextProps.value) &&\n      nextProps.value !== null\n    ) {\n      nextState.value = toString(nextProps.value);\n      if (this.state.hasChanged === false) {\n        nextState.hasChanged = true;\n      }\n    }\n\n    this.setState(nextState);\n  },\n\n  onChange: function(newValue) {\n    this.props.onChange(newValue);\n  },\n\n  handleChoiceSelection: function(key, event) {\n    const selectChoice = () => {\n      const pos = this.state.selectedTagPos;\n      const tag = '{{' + key + '}}';\n\n      this.isInserting = true;\n      if (pos) {\n        this.codeMirror.replaceRange(\n          tag,\n          { line: pos.line, ch: pos.start },\n          { line: pos.line, ch: pos.stop }\n        );\n      } else {\n        this.codeMirror.replaceSelection(tag, 'end');\n      }\n      this.isInserting = false;\n      this.codeMirror.focus();\n\n      this.setState({ isChoicesOpen: false, selectedTagPos: null });\n    };\n    if (this.state.codeMirrorMode) {\n      selectChoice();\n    } else if (this.props.readOnly) {\n      // hackety hack to stop dropdown choices from toggling\n      event.stopPropagation();\n      this.isInserting = true;\n      this.onChange('{{' + key + '}}');\n      this.isInserting = false;\n      this.setState({ isChoicesOpen: false });\n    } else {\n      this.switchToCodeMirror(selectChoice);\n    }\n  },\n\n  onFocusWrapper: function() {\n    this.switchToCodeMirror(() => {\n      this.codeMirror.focus();\n      this.codeMirror.setCursor(this.codeMirror.lineCount(), 0);\n    });\n  },\n\n  focus() {\n    if (this.codeMirror) {\n      this.focusCodeMirror();\n    } else {\n      this.switchToCodeMirror(() => {\n        this.focusCodeMirror();\n      });\n    }\n  },\n\n  focusCodeMirror() {\n    if (this.codeMirror) {\n      this.codeMirror.focus();\n    }\n  },\n\n  onFocusCodeMirror() {\n    this.setState({ hasFocus: true });\n    this.props.onFocus();\n  },\n\n  onBlur() {\n    this.setState({ hasFocus: false }, this.props.onBlur);\n  },\n\n  insertBtn: function() {\n    if (\n      this.props.readOnly ||\n      (this.isReadOnly() && !this.hasReadOnlyControls())\n    ) {\n      return null;\n    }\n    const onInsertClick = function() {\n      this.setState({ selectedTagPos: null });\n      this.onToggleChoices();\n    };\n\n    const props = {\n      typeName: this.props.typeName,\n      ref: ref(this, 'toggle'),\n      onClick: onInsertClick.bind(this),\n      readOnly: this.isReadOnly(),\n      field: this.props.field,\n    };\n    return this.props.config.createElement('insert-button', props, 'Insert...');\n  },\n\n  choices: function() {\n    if (this.isReadOnly()) {\n      return null;\n    }\n\n    return this.props.config.createElement('choices', {\n      typeName: this.props.typeName,\n      ref: ref(this, 'choices'),\n      onFocusSelect: this.focusCodeMirror,\n      choices: this.state.replaceChoices,\n      open: this.state.isChoicesOpen,\n      ignoreCloseNodes: this.getCloseIgnoreNodes,\n      onSelect: this.handleChoiceSelection,\n      onClose: this.onCloseChoices,\n      isAccordion: this.props.isAccordion,\n      field: this.props.field,\n      onChoiceAction: this.onChoiceAction,\n    });\n  },\n\n  onChoiceAction: function(choice) {\n    this.setState({\n      isChoicesOpen: !!choice.isOpen,\n    });\n    this.onStartAction(choice.action, choice);\n  },\n\n  wrapperTabIndex() {\n    if (this.props.readOnly || this.state.codeMirrorMode) {\n      return null;\n    }\n    return this.props.tabIndex || 0;\n  },\n\n  onKeyDown(event) {\n    if (!this.isReadOnly()) {\n      if (event.keyCode === keyCodes.ESC) {\n        event.preventDefault();\n        event.stopPropagation();\n        if (this.state.isChoicesOpen) {\n          this.onToggleChoices();\n          this.focusCodeMirror();\n        }\n      } else if (!this.state.isChoicesOpen) {\n        // TODO: sane shortcut for opening choices\n        // Below does not work yet. Ends up dumping { into search input.\n        // if (this.codeMirror) {\n        //   if (event.keyCode === keyCodes['['] && event.shiftKey) {\n        //     const cursor = this.codeMirror.getCursor();\n        //     const value = this.codeMirror.getValue();\n        //     const lines = value.split('\\n');\n        //     const line = lines[cursor.line];\n        //     if (line) {\n        //       const prevChar = line[cursor.ch - 1];\n        //       if (prevChar === '{') {\n        //         this.onToggleChoices();\n        //       }\n        //     }\n        //   }\n        // }\n      } else {\n        if (this.choicesRef && this.choicesRef.onKeyDown) {\n          this.choicesRef.onKeyDown(event);\n        }\n      }\n    }\n  },\n\n  render: function() {\n    return this.renderWithConfig();\n  },\n\n  renderDefault: function() {\n    const textBoxClasses = cx(\n      _.extend({}, this.props.classes, {\n        'pretty-text-box': true,\n        placeholder: this.hasPlaceholder(),\n        'has-focus': this.state.hasFocus,\n      })\n    );\n\n    // Render read-only version.\n    return (\n      <div\n        className={cx({\n          'pretty-text-wrapper': true,\n          'choices-open': this.state.isChoicesOpen,\n        })}\n        onKeyDown={this.onKeyDown}\n        onMouseEnter={this.switchToCodeMirror}\n        onTouchStart={this.switchToCodeMirror}\n        renderWith={this.renderWith('PrettyTextInputWrapper')}\n        role=\"presentation\"\n      >\n        <div\n          className=\"pretty-text-click-wrapper\"\n          onFocus={this.onFocusWrapper}\n          renderWith={this.renderWith('PrettyTextInputClickWrapper')}\n          // we need to handle onFocus events for this div for accessibility\n          // when the screen reader enters the field it should be the equivalent\n          // of a focus click event\n          role=\"textbox\"\n          tabIndex=\"0\"\n        >\n          <div\n            className={textBoxClasses}\n            onBlur={this.onBlur}\n            renderWith={this.renderWith('PrettyTextInputTabTarget')}\n            role=\"presentation\"\n            tabIndex={this.wrapperTabIndex()}\n          >\n            <div\n              className=\"internal-text-wrapper\"\n              ref={ref(this, 'textBox')}\n              renderWith={this.renderWith('PrettyTextInputInternalTextWrapper')}\n            />\n          </div>\n        </div>\n        {this.insertBtn()}\n        {this.choices()}\n      </div>\n    );\n  },\n\n  getCloseIgnoreNodes: function() {\n    return this.toggleRef;\n  },\n\n  onToggleChoices: function() {\n    this.setChoicesOpen(!this.state.isChoicesOpen);\n  },\n\n  setChoicesOpen: function(isOpen) {\n    const action = isOpen ? 'open-replacements' : 'close-replacements';\n    this.onStartAction(action);\n    this.setState({ isChoicesOpen: isOpen });\n  },\n\n  onCloseChoices: function() {\n    if (this.state.isChoicesOpen) {\n      this.setChoicesOpen(false);\n    }\n  },\n\n  createEditor: function() {\n    if (this.state.codeMirrorMode) {\n      this.createCodeMirrorEditor();\n    } else {\n      this.createReadonlyEditor();\n    }\n  },\n\n  updateEditor: function() {\n    if (this.state.codeMirrorMode) {\n      const codeMirrorValue = this.codeMirror.getValue();\n      if (!this.hasPlaceholder() && codeMirrorValue !== this.state.value) {\n        // switch back to read-only mode to make it easier to render\n        this.removeCodeMirrorEditor();\n        this.createReadonlyEditor();\n        this.setState({\n          codeMirrorMode: false,\n        });\n      }\n    } else {\n      this.createReadonlyEditor();\n    }\n  },\n\n  maybeSetCursorPosition(position) {\n    if (position && this.codeMirror) {\n      this.codeMirror.setCursor(position);\n    }\n  },\n\n  maybeCodeMirrorOperation(ops) {\n    if (this.codeMirror) {\n      this.codeMirror.operation(ops);\n    }\n  },\n\n  createCodeMirrorEditor: function() {\n    const options = {\n      tabindex: this.props.tabIndex || 0,\n      lineWrapping: true,\n      placeholder: toString(\n        this.props.config.fieldPlaceholder(this.props.field)\n      ),\n      value: toString(this.state.value),\n      readOnly: false,\n      mode: null,\n      extraKeys: {\n        Tab: false,\n        'Shift-Tab': false,\n      },\n    };\n\n    const textBox = this.textBoxRef;\n    textBox.innerHTML = ''; // release any previous read-only content so it can be GC'ed\n\n    this.codeMirror = this.props.config.codeMirror()(textBox, options);\n    this.codeMirror.on('change', this.onCodeMirrorChange);\n    this.codeMirror.on('focus', this.onFocusCodeMirror);\n\n    this.debouncedOnChangeAndTagCodeMirror = _.debounce(() => {\n      this.onChangeAndTagCodeMirror();\n    }, 200);\n\n    const pos = this.codeMirror ? this.codeMirror.getCursor() : null;\n    this.tagCodeMirror(pos);\n  },\n\n  tagCodeMirror: function(cursorPosition) {\n    const positions = this.state.translator.getTagPositions(\n      this.codeMirror.getValue()\n    );\n    const self = this;\n\n    const tagOps = function() {\n      positions.forEach(function(pos) {\n        const node = self.createTagNode(pos);\n        self.codeMirror.markText(\n          { line: pos.line, ch: pos.start },\n          { line: pos.line, ch: pos.stop },\n          { replacedWith: node, handleMouseEvents: true }\n        );\n      });\n    };\n\n    // Make sure we apply those operations after React has made its rendering pass.\n    // As React 16 is asynchronous and uses rAF, it's safe to assume that this will\n    // be called after React has patched the DOM.\n    //\n    // But if we are calling this function from CodeMirror itself, we want to stay\n    // in sync with it's internal state.\n    if (this.debouncedOnChangeAndTagCodeMirror) {\n      this.maybeCodeMirrorOperation(tagOps);\n      this.maybeSetCursorPosition(cursorPosition);\n    } else {\n      requestAnimationFrame(() => {\n        this.maybeCodeMirrorOperation(tagOps);\n        this.maybeSetCursorPosition(cursorPosition);\n      });\n    }\n  },\n\n  onChangeAndTagCodeMirror() {\n    this.onChange(this.codeMirror.getValue());\n    this.tagCodeMirror();\n  },\n\n  onCodeMirrorChange: function() {\n    const newValue = this.codeMirror.getValue();\n    this.setState({ value: newValue });\n\n    // Immediately change and tag if inserting.\n    if (this.isInserting) {\n      this.onChangeAndTagCodeMirror();\n    }\n    // Otherwise, debounce so CodeMirror doesn't die.\n    else {\n      this.debouncedOnChangeAndTagCodeMirror();\n    }\n  },\n\n  /* Return true if we should render the placeholder */\n  hasPlaceholder: function() {\n    return !this.state.value;\n  },\n\n  createReadonlyEditor: function() {\n    const textBoxNode = this.textBoxRef;\n\n    if (this.hasPlaceholder()) {\n      return ReactDOM.render(\n        <span renderWith={this.renderWith('PrettyTextInputPlaceholder')}>\n          {this.props.field.placeholder}\n        </span>,\n        textBoxNode\n      );\n    }\n\n    const tokens = this.props.config.tokenize(this.state.value);\n    const self = this;\n    const nodes = tokens.map(function(part, i) {\n      if (part.type === 'tag') {\n        const label = self.state.translator.getLabel(part.value);\n        const props = {\n          typeName: self.props.typeName,\n          key: i,\n          tag: part.value,\n          replaceChoices: self.state.replaceChoices,\n          field: self.props.field,\n        };\n        return self.props.config.createElement('pretty-tag', props, label);\n      }\n      return <span key={i}>{part.value}</span>;\n    });\n\n    return ReactDOM.render(\n      <span renderWith={this.renderWith('PrettyTextInputTokens')}>\n        {nodes}\n      </span>,\n      textBoxNode\n    );\n  },\n\n  removeCodeMirrorEditor: function() {\n    const textBoxNode = this.textBoxRef;\n\n    const cmNode = textBoxNode.firstChild;\n    textBoxNode.removeChild(cmNode);\n\n    this.codeMirror.off('change', this.onCodeMirrorChange);\n    this.codeMirror.off('focus', this.onFocusCodeMirror);\n\n    if (this.debouncedOnChangeAndTagCodeMirror) {\n      // Cancel any trailing invocation\n      this.debouncedOnChangeAndTagCodeMirror.cancel();\n      this.debouncedOnChangeAndTagCodeMirror = null;\n\n      // Flush changes\n      this.onChange(this.codeMirror.getValue());\n    }\n\n    this.codeMirror = null;\n  },\n\n  switchToCodeMirror: function(cb) {\n    if (this.isReadOnly()) {\n      return; // never render in code mirror if read-only\n    }\n    if (!this.props.readOnly) {\n      if (!this.state.codeMirrorMode) {\n        this.setState({ codeMirrorMode: true }, () => {\n          if (this.codeMirror && _.isFunction(cb)) {\n            cb();\n          }\n        });\n      }\n    }\n  },\n\n  onTagClick: function() {\n    const cursor = this.codeMirror.getCursor();\n    const pos = this.state.translator.getTrueTagPosition(\n      this.state.value,\n      cursor\n    );\n\n    this.setState({ selectedTagPos: pos });\n    this.onToggleChoices();\n  },\n\n  createTagNode: function(pos) {\n    const node = document.createElement('span');\n    const label = this.state.translator.getLabel(pos.tag);\n    const config = this.props.config;\n\n    const props = {\n      typeName: this.props.typeName,\n      onClick: this.onTagClick,\n      field: this.props.field,\n      tag: pos.tag,\n    };\n\n    ReactDOM.render(config.createElement('pretty-tag', props, label), node);\n\n    return node;\n  },\n});\n"],"mappings":";;;;;;;;;;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAHA;AAMA;AACA;AAFA;AAMA;AAEA;AACA;AACA;AACA;AACA;AADA;AAJA;AASA;AACA;AACA;AAHA;AAMA;AACA;AAFA;AA/BA;AAuCA;AACA;AACA;AACA;AACA;AALA;AAQA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AALA;AAJA;AAcA;AACA;AACA;AACA;AACA;AALA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAFA;AAKA;AACA;AAFA;AAKA;AACA;AACA;AACA;AACA;AADA;AAJA;AASA;AACA;AACA;AAHA;AAMA;AACA;AAFA;AAKA;AACA;AACA;AAHA;AAMA;AACA;AACA;AAHA;AAMA;AACA;AACA;AACA;AAJA;AA3CA;AAqDA;AACA;AACA;AACA;AACA;AAJA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvHA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAJA;AADA;AAQA;AAAA;AAAA;AAAA;AAAA;AATA;AAeA;AACA;AACA;AADA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AACA;AAAA;AAAA;AADA;AAKA;AACA;AAAA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AADA;AAQA;AAXA;AAcA;AACA;AACA;AAOA;AACA;AAOA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAMA;AAAA;AAEA;AACA;AAAA;AAAA;AADA;AAMA;AAAA;AARA;AACA;AAWA;;;;;AACA;AAAA;AACA;AADA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAHA;AAHA;AAQA;AACA;;;AACA;AACA;AACA;AAEA;AACA;AADA;AAGA;;;AAEA;AACA;AACA;AADA;AAGA;;;AAEA;AACA;AACA;AAAA;AACA;AACA;AADA;AAGA;;;AAEA;AACA;AACA;;;AAEA;AACA;AACA;;;AAEA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AAGA;AAIA;AAEA;AAGA;AAAA;AAIA;AAEA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAWA;AAAA;AAAA;AAAA;AAOA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAGA;AAAA;AAAA;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;AAGA;AAAA;AAAA;AAGA;AACA;AAnBA;AAuBA;AAAA;AACA;AAAA;AAAA;AAGA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAHA;AALA;AAYA;AAdA;AAoBA;;;;AArIA;AACA;AAuIA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;AACA;AAAA;AAFA;AAHA;AACA;AAWA;;;;;;;;;;;;ACxPA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;;;;;;;;;AAUA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AASA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AACA;AAQA;AAKA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAAA;AACA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAEA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AAIA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAXA;AAaA;AAEA;AACA;AACA;AADA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAHA;AACA;AAOA;AAEA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AATA;AAYA;AACA;AACA;AAEA;AACA;AANA;AAOA;AACA;AARA;AAWA;AACA;AACA;AACA;AACA;AALA;AAQA;AACA;AACA;AAHA;AAWA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AADA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAFA;AATA;AAeA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AACA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAFA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AAAA;AAKA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAKA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAJA;AAOA;AAEA;AACA;AA7hBA;;;;A","sourceRoot":""}